<p><strong>T</strong>his edition of Mastering Delphi marks the seventh year of the Delphi era, as it took Bor- land two years to release the latest incarnation of Delphi (along with its Linux twin, Kylix). As it has for many other programmers, Delphi has been my primary interest throughout these years; and writing, consulting, teaching, and speaking at conferences about Delphi have absorbed more and more of my time, leaving other languages and programming tools in the dust of my office. Because my work and my life are quite intertwined, many people have been involved in both, and I wish I had enough space and time to thank them all as they deserve. Instead, I’ll just mention a few particular people and say a warm “Thank You” to the entire Delphi community (especially for the Spirit of Delphi 1999 Award I’ve been happy to share with Bob Swart).</p>

<p>The first official thanks are for the Borland programmers and managers who made Delphi possible and continue to improve it: Chuck Jazdzewski, Danny Thorpe, Eddie Churchill, Allen Bauer, Steve Todd, Mark Edington, Jim Tierney, Ravi Kumar, Jörg Weingarten, Anders Ohlsson, and all the others I have not had a chance to meet. I’d also like to give par- ticular mention to my friends Ben Riga (the current Delphi product manager), John Kaster and David Intersimone (at Borland’s Developer Relations), and others who have worked at Borland, including Charlie Calvert, Zack Urlocker and Nan Borreson.</p>

<p>The next thanks are for the Sybex editorial and production crew, many of whom I don’t even know. Special thanks go to Pete Gaughan, Leslie Light, Denise Santoro Lincoln, and Diane Lowery; I’d also like to thank Richard Mills, Kristine O’Callaghan, and Kris Warrenburg.</p>

<p>This edition of <em>Mastering Delphi</em> has once again had an incredibly picky and detailed review from Delphi R&amp;D team member Danny Thorpe. His highlights and comments in this and past editions have improved the book in all areas: technical content, accuracy, examples, and even readability. Thanks a lot. Previous editions also had special contributions: Tim Gooch worked on Part V for <em>Mastering Delphi 4,</em> and Giuseppe Madaffari contributed database mate- rial for the Delphi 5 edition. For this edition, Guy Smith-Ferrier rewrote the chapter on ADO, and Nando Dessena helped me with the InterBase chapter. Many improvements to the text and sample programs were suggested by technical reviewers of past editions (Juancarlo Añez, Ralph Friedman, Tim Gooch, and Alain Tadros) and in other reviews over the years by Bob Swart, Giuseppe Madaffari, and Steve Tendon.</p>

<p>Special thanks go to my friends Bruce Eckel, Andrea Provaglio, Norm McIntosh, Johanna and Phil of the BUG-UK, Ray Konopka, Mark Miller, Cary Jensen, Chris Frizelle of <em>The Delphi Magazine,</em> Foo Say How, John Howe, Mike Orriss, Chad “Kudzu” Hower, Dan Miser, Marco Miotti, and the entire D&amp;D Team (Paolo, Andrea, Uberto, Nando, Giuseppe, and Mr. Coke). Also, a very big “Thank You” to all the attendees of my Delphi programming courses, seminars, and conferences in Italy, the United States, France, the United Kingdom, Singapore, the Netherlands, Germany, Sweden...</p>

<p>My biggest thanks go to my wife Lella who had to endure yet another many-months-long book-writing session and too many late nights (after spending the evenings with our daughter, Benedetta—I’ll thank her with a hug, as Daddy’s book looks quite boring to her). Many of our friends (and their kids) provided healthy breaks in the work: Sandro and Monica with Luca, Stefano and Elena, Marco and Laura with Matteo, Bianca, Luca and Elena with Tommaso, Chiara and Daniele with Leonardo, Laura, Vito and Marika with Sofia. Our parents, brothers, sisters, and their families were very supportive, too. It was nice to spend some of our free time with them and our six nephews—Matteo, Andrea, Giacomo, Stefano, Andrea, and Pietro.</p>

<p>Finally, I would like to thank all of the people, many of them unknown, who enjoy life and help to build a better world. If I never stop believing in the future and in peace, it is also because of them.</p>

<h2 id="thestructureofthebook">The Structure of the Book</h2>

<p>The book is divided into four parts:</p>

<ul>
<li><p>Part I, “Foundations,” introduces new features of the Delphi 6 Integrated Develop- ment Environment (IDE) in Chapter 1, then moves to the Object Pascal language and to the run-time library (RTL) and Visual Component Library (VCL), providing both foundations and advanced tips.</p></li>

<li><p>Part II, “Visual Programming,” covers standard components, Windows common con- trols, graphics, menus, dialogs, scrolling, docking, multipage controls, Multiple Docu- ment Interface, the Action List and Action Manager architectures, and many other topics. The focus is on both the VCL and CLX libraries. The final chapters discuss the development of custom components and the use of libraries and packages.</p></li>

<li><p>Part III, “Database Programming,” covers plain database access, in-depth coverage of the data-aware controls, client/server programming, dbExpress, InterBase, ADO and dbGo, DataSnap (or MIDAS), and the development of custom data-aware controls and data sets.</p></li>

<li><p>Part IV, “Beyond Delphi: Connecting with the World,” first discusses COM, OLE Automation, and COM+. Then it moves to Internet programming, covering TCP/IP sockets, Internet protocols and Indy, Web server-side extensions (with WebBroker and WebSnap), XML, and the development of Web services.</p></li>
</ul>

<p>As this brief summary suggests, the book covers topics of interest to Delphi users at nearly all levels of programming expertise, from “advanced beginners” to component developers.</p>

<p>In this book, I’ve tried to skip reference material almost completely and focus instead on techniques for using Delphi effectively. Because Delphi provides extensive online documen- tation, to include lists of methods and properties of components in the book would not only be superfluous, it would also make it obsolete as soon as the software changes slightly. I sug- gest that you read this book with the Delphi Help files at hand, to have reference material readily available.</p>

<p>However, I’ve done my best to allow you to read the book away from a computer if you prefer. Screen images and the key portions of the listings should help in this direction. The book uses just a few conventions to make it more readable. All the source code elements, such as keywords, properties, classes, and functions, appear in this font, and code excerpts are formatted as they appear in the Delphi editor, with boldfaced keywords and italic com- ments and strings.</p>

<h2 id="freesourcecodeoncdandtheweb">Free Source Code on CD (and the Web)</h2>

<p>This book focuses on examples. After the presentation of each concept or Delphi compo- nent, you’ll find a working program example (sometimes more than one) that demonstrates how the feature can be used. All told, there are about 300 examples presented in the book. These programs are directly available on the companion CD-ROM. The same material is also available on my Web site (www.marcocantu.com), where you’ll also find updates and examples from past editions. Inside the back cover of the book, you’ll find more information about the CD. Most of the examples are quite simple and focus on a single feature. More complex examples are often built step-by-step, with intermediate steps including partial solu- tions and incremental improvements.</p>

<p>Some of the database examples also require you to have the Delphi sample database DBDEMOS installed; it is part of the default Delphi installation. Others require the InterBase EMPLOYEE sample database.</p>

<p>Beside the source code files, the CD hosts the ready-to-use compiled programs. There is also an HTML version of the source code, with full syntax highlighting, along with a complete cross-reference of keywords and identifiers (class, function, method, and property names, among others). The cross-reference is an HTML file, so you’ll be able to use your browser to easily find all the programs that use a Delphi keyword or identifier you’re looking for (not a full search engine, but close enough).</p>

<p>The directory structure of the sample code is quite simple. Basically, each chapter of the book has its own folder, with a subfolder for each example (e.g., 06\Borders). In the text, the examples are simply referenced by name (e.g., Borders).</p>

<p>To change an example, first copy it (or the entire md6code folder) to your hard disk, but before opening it remember to set the read-only flag to False (it is True by default on the read-only media)</p>

<p>Be sure to read the source code archive’s Readme file, which contains important information about using the software legally and effectively.</p>

<h2 id="thedelphi6ide">The Delphi 6 IDE</h2>

<p>The Delphi 6 IDE includes large and small changes that will really improve a programmer’s productivity. Among the key features are the introduction of the Object TreeView for every designer, an improved Object Inspector, extended code completion, and loadable views, including diagrams and HTML.</p>

<p>Most of the features are quite easy to grasp, but it’s worth examining them with some care so that you can start using Delphi 6 at its full potential right away. You can see an overall image of Delphi 6 IDE, highlighting some of the new features, in Figure 1.1.</p>

<p><img src="https://aj-86.github.io/WebpageTest/Mastering%20Delphi%206%20-%20Part%201_files/image033.jpg" alt="img" /></p>

<p><strong>F I G U R E 1 . 1 :</strong></p>

<p>The Delphi 6 IDE: Notice the Object TreeView and the Diagram view.</p>

<h4 id="theobjecttreeview">The Object TreeView</h4>

<p>Delphi 5 introduced a TreeView for data modules, where you could see the relations among nonvisual components, such as datasets, fields, actions, and so on. Delphi 6 extends the idea by providing an Object TreeView for every designer, including plain forms. The Object TreeView is placed by default above the Object Inspector; use the View ➢ Object TreeView command in case it is hidden.</p>

<p>The Object TreeView shows all of the components and objects on the form in a tree, rep- resenting their relations. The most obvious is the parent/child relation: Place a panel on a form, a button inside it and one outside of the panel. The tree will show the two buttons, one under the form and the other under the panel, as in Figure 1.1. Notice that the TreeView is synchronized with the Object Inspector and Form Designer, so as you select an item and change the focus in any one of these three tools, the focus changes in the other two tools.</p>

<p>Besides parent/child, the Object TreeView shows also other relations, such as owner/owned, component/subobject, collection/item, plus various specific ones, including dataset/connection and data source/dataset relations. Here, you can see an example of the structure of a menu in the tree</p>

<p><img src="https://aj-86.github.io/WebpageTest/Mastering%20Delphi%206%20-%20Part%201_files/image037.jpg" alt="img" /></p>

<p>At times, the TreeView also displays “dummy” nodes, which do not correspond to an actual object but do correspond to a predefined one. As an example of this behavior, drop a Table component (from the BDE page) and you’ll see two grayed icons for the session and the alias. Technically, the Object TreeView uses gray icons for components that do not have design-time persistence. They are real components (at design time and at run time), but because they are default objects that are constructed at run time and have no persistent data that can be edited at design time, the Data Module Designer does not allow you to edit their properties. If you drop a Table on the form, you’ll also see items with a red question mark enclosed in a yellow circle next to them. This symbol indicates partially undefined items (there used to be a red square around those items in Delphi 5).</p>

<p>The Object TreeView supports multiple types of <em>dragging</em>:</p>

<ul>
<li><p>You can select a component from the palette (by clicking it, not actually dragging it), move the mouse over the tree, and click a component to drop it there. This allows you to drop a component in the proper container (form, panel, and others) regardless of the fact that its surface might be totally covered by other components, something that pre- vents you from dropping the component in the designer without first rearranging those components.</p></li>

<li><p>You can drag components within the TreeView—for example, moving a component from one container to another—something that, with the Form Designer, you can do only with cut and paste techniques. Moving instead of cutting provides the advantage that if you have connections among components, these are not lost, as happens when you delete the component during the cut operation.</p></li>

<li><p>You can drag components from the TreeView to the Diagram view, as we’ll see later.</p></li>
</ul>

<p>Right-clicking any element of the TreeView displays a shortcut menu similar to the com- ponent menu you get when the component is in a form (and in both cases, the shortcut menu may include items related to the custom component editors). You can even delete items from the tree.</p>

<p>The TreeView doubles also as a collection editor, as you can see here for the Columns prop- erty of a ListView control. In this case, you can not only rearrange and delete items, but also add new items to the collection.</p>

<p><img src="https://aj-86.github.io/WebpageTest/Mastering%20Delphi%206%20-%20Part%201_files/image041.jpg" alt="img" /></p>

<p>You can print the contents of the Object TreeView for documentation purposes. Simply select the window and use the File ➢ Print command, as there is no Print command in the shortcut menu.</p>

<h4 id="loadableviews">Loadable Views</h4>

<p>Another important change has taken place in the Code Editor window. For any single file loaded in the IDE, the editor can now show multiple views, and these views can be defined programmatically and added to the system, then loaded for given files—hence the name <em>load- able</em> views.</p>

<p>The most frequently used view is the Diagram page, which was already available in Delphi 5 data modules, although it was less powerful. Another set of views is available in Web applica- tions, including an HTML Script view, an HTML Result preview, and many others dis- cussed in Chapter 22.</p>

<h5 id="thediagramview">The Diagram View</h5>

<p>Along with the TreeView, another feature originally introduced in Delphi 5 Data Modules and now available for every designer is the Diagram view. This view shows dependencies among components, including parent/child relations, ownership, linked properties, and generic rela- tions. For dataset components, it also supports master/detail relations and lookup connections. You can even add your comments in text blocks linked to specific components.</p>

<p>The Diagram is not built automatically. You must drag components from the TreeView to the diagram, which will automatically display the existing relations among the components you drop there. In Delphi 6, you can now select multiple items from the Object TreeView and drag them all at once to the Diagram page.</p>

<p>What’s nice is that you can set properties by simply drawing arrows between the compo- nents. For example, after moving an edit and a label to Diagram, you can select the Property Connector icon, click the label, and drag the mouse cursor over the edit. When you release the mouse button, the Diagram will set up a property relation based on the FocusControl property, which is the only property of the label referring to an edit control. This situation is depicted in Figure 1.2.</p>

<p>As you can see, setting properties is <em>directional</em>: If you drag the property relation line from the edit to the label, you end up trying to use the label as the value of a property of the edit box. Because this isn’t possible, you’ll see an error message indicating the problem and offer- ing to connect the components in the opposite way.</p>

<p>In Delphi 6, the Diagram view allows you to create multiple diagrams for each Delphi unit—that is, for each form or data module. Simply give a name to the diagram and possibly add a description, click the New Diagram button, prepare another diagram, and you’ll be able to switch back and forth between diagrams using the combo box available in the toolbar of the Diagram view.</p>

<p><img src="https://aj-86.github.io/WebpageTest/Mastering%20Delphi%206%20-%20Part%201_files/image049.jpg" alt="img" /></p>

<p><strong>F I G U R E 1 . 2 :</strong></p>

<p>The Diagram view allows you to connect components using the Property connector.</p>

<p>Although you can use the Diagram view to set up relations, its main role is to document your design. For this reason, it is important to be able to print the content of this view. Using the standard File ➢ Print command while the Diagram is active, Delphi prompts you for options, as you can see in Figure 1.3, allowing you to customize the output in many ways.</p>

<p><img src="https://aj-86.github.io/WebpageTest/Mastering%20Delphi%206%20-%20Part%201_files/image052.jpg" alt="img" /></p>

<p><strong>F I G U R E 1 . 3 :</strong></p>

<p>The Print Options for the Diagram view</p>

<p>The information in the Data Diagram view is saved in a separate file, not as part of the DFM file. Delphi 5 used design-time information (DTI) files, which had a structure similar to INI files. Delphi 6 can still read the older .DTI format, but uses the new Delphi Diagram Portfolio format (.DDP). These files apparently use the DFM binary format (or a similar one), so they are not editable as text. All of these files are obviously useless at run time (it makes no sense to include them in the compilation of the executable file).</p>

<h4 id="anidefortwolibraries">An IDE for Two Libraries</h4>

<p>Another very important change I just want to introduce here is the fact that Delphi 6, for the first time, allows you to use to different component libraries, VCL (Visual Components Library) and CLX (Component Library for Cross-Platform). When you create a new project, you simply choose which of the two libraries you want to use, starting with the File ➢ New ➢ Application command for a classic VCL-based Windows program and with the File ➢ New ➢ CLX Application command for a new CLX-based portable application.</p>

<p>Creating a new project or opening an existing one, the Component Palette is rearranged to show only the controls related to the current library (although most of them are actually shared). This topic is fully covered in Chapter 6, so I don’t want to get into the details here; I’ll just underline that you can use Delphi 6 to build applications you can compile right away for Linux using Kylix. The effect of this change on the IDE is really quite large, as many things “under the hood” had to be reengineered. Only programmers using the ToolsAPI and other advanced elements will notice all these internal differences, as they are mostly trans- parent to most users.</p>

<h4 id="smallerenhancements">Smaller Enhancements</h4>

<p>Besides this important change and others I’ll discuss in later sections, such as the update of the Object Inspector and of code completion, there are small (but still quite important) changes in the Delphi 6 IDE. Here is a list of these changes:</p>

<ul>
<li>There is a new Window menu in the IDE. This menu lists the open windows, some- thing you could obtain in the past using the Alt+0 keys. This is really very handy, as windows often end up behind others and are hard to find. (Thanks, Borland, for listen- ing to this and other simple but effective requests from users.)</li>
</ul>

<p>Two entries of the Main Window registry section of Delphi (under \Software\Borland\ Delphi\6.0 for the current user) allow you to hide this menu and disable its alphabetic sort order. This registry keys use strings (in place of Boolean values) where “-1” indicates true and “0” false.</p>

<ul>
<li><p>The File menu doesn’t include specific items for creating new forms or applications. These commands have been increased in number and grouped under the File ➢ New secondary menu. The Other command of this menu opens the New Item dialog box (the Object Repository) as the File ➢ New command did in the past.</p></li>

<li><p>The Component Palette local menu has a submenu listing all of the palette pages in alphabetic order. You can use it to change the active page, particularly when it is not visible on the screen.</p></li>
</ul>