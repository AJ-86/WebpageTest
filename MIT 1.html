<p>Unknown Speaker <br />
The following content is provided under a Creative Commons licence. Your support will help MIT OpenCourseWare continue to offer high quality educational resources for free. To make a donation or view additional materials from hundreds of MIT courses, visit MIT OpenCourseWare at ocw mit.edu.</p>

<p>Eric Grimson <br />
Good morning. Try it again. Good morning. Thank you. This is 600, also known as introduction to computer science and programming. My name is Eric Grimson. Together, Professor John Guttag. Over here, we're going to be lecturing the course this term, I want to give you a heads up, you're getting some serious firepower. This term, John was department head for 10 years felt like a century. In the course six, I'm the current department head and core six, John's been lecturing for 30 years, roughly. All right, I'm the young guy, I've only been lecturing for 25 years, you can tell I have less grey hair than he does. What I'm trying to say to you is we take this course really seriously, we hope you do as well. But we think it's really important for the department to help everybody learn about computation. And that's what this course is about. What I want to do today is three things. I'm going to start construction and say start, I'm going to do it in middle, a little bit of administrivia, the kinds of things you need to know about how we're going to run the course, I want to talk about the goals of the course, what it is, you'll be able to do at the end of this course when you get through it. And then I want to begin talking about the concepts and tools of computational thinking, which is what we're primarily going to focus on here, we're going to try and help you learn how to think like a computer scientist. And we're going to begin talking about that towards the end of this lecture. And of course, throughout the rest of the lecture is the carry on. Right, let's start with the goals. And I'm going to give you goals in two levels. The strategic goals are the following. We want to help prepare freshmen and sophomores who are interested in majoring in core six, to get an easy entry into the department, especially for those students who don't have a lot of prior programming experience. If you're in that category, don't panic, you're going to get it, we're going to help you ramp in and you'll certainly be able to start the core six curriculum, and do just fine and still finish on target. We don't expect everybody to be a core six major, contrary to popular opinion. So for those of you not in that category, the second thing we want to do is we want to help students who don't plan to major in core six, to feel justifiably confident in their ability to write and read small pieces of code. For all students, what we want to do is we want to give you an understanding of the role computation can and cannot play in tackling technical problems. So that you will come away with a sense of what you can do, what you can't do, and what kinds of things you should use to tackle complex problems. And finally, we want to position all students so that you can easily if you like, compete for things like your ops and summer jobs, because you'll have an appropriate level of confidence and competence in your ability to do computational problem solving. Those are the strategic goals. Now, this course is primarily aimed at students who have little or no prior programming experience. As a consequence, we believe that no student here is under qualified. For this course, you're all MIT students, you're all qualified to be here. But we also hope that there aren't any students here who are overqualified for this course. And what do I mean by that if you've done a lot of prior programming, this is probably not the best course for you. And if you're in that category, I would please encourage you to talk to John or I, after class about what your goals are, what kind of experience you have, and how we might find you a course that better meets your goals. Second reason, we don't want overqualified students in the class sounds a little nasty. But the second reason is an overqualified student, somebody who's I don't know, programmed for Google for the last five years, is going to have an easy time in this course. But we don't want such a student accidentally intimidating the rest of you. We don't want you to feel inadequate, when you're simply inexperienced. And so it really is a course aimed at students with little or no prior programming experience. And again, if you're not in that category, talk to John or I after class, and we'll help you figure out where you might want to go. Okay, those are the top level goals of the course. Let's talk sort of at a more tactical level about what do we want you to know, in this course, what do we want you to be able to do by the time you leave this course. So here are the skills that we would like you to acquire. Right, the first skill we want you to acquire, as we want you to be able to use the basic tools of computational thinking to write small scale programmes. We're going to keep coming back to that idea of I'm going to call it computational thinking. And that's so you can write small pieces of code and small is not derogatory here. By the way, it just says the size of things you're going to be able to do. Second skill we want you to have at the end of this course, is the ability to use the vocabulary of computational tools, in order to be able to understand programmes written by others. So you're going to be able to write, you're going to be able to read.</p>

<p>This ladder skill, by the way, is incredibly valuable. Because you don't want to do everything from scratch yourself, you want to be able to look at what has been created by somebody else and understand what is inside of there, whether it works correctly and how you can build on it. This is one of the few places where plagiarism is an okay thing is not bad to you, like learn from the skills of others in order to create something you want to write. Although we'll come back to plagiarism as a bad thing later on. Third thing we want you to do is to understand the fundamental, both capabilities and limitations of computation, and the cost associated with them. And that ladder statement sounds funny, you don't think of computation having limits, but they do. There are some things that cannot be computed, we want you to understand where those limits are. So you're going to be able to understand abilities and limits.</p>

<p>And then finally, the last tactical skill that you're going to get out of this course is you're going to have the ability to map scientific problems into a computational framework. So you're going to be able to take a description of a problem and map it into something computational. Now, if you think about it, well, it sounds like grammar school, we're going to teach you to read, I'm going to teach you to write, I'm going to teach you to understand what you can and cannot do. And most importantly, we're going to try and give you the start of an ability to take a description of a problem from some other domain, and figure out how to map it into that domain of computation. So you can do the reading and writing that you want to do. Okay, in a few minutes, we're going to start talking then about what is computation? How are we going to start building those tools, but that's what you should take away. That's what you're going to gain out of this course, by the time you're done. Now, let me take a sidebar for about five minutes to talk about course administration, the administrivia things that we're going to do in the course, just so you know what the rules are. Right? So class is two hours a lecture a week, you obviously know where and you know, when, because you're here, Tuesdays and Thursdays at 11. One hour of recitation a week on Fridays, and we'll come back in a second to how you're going to get set up for that. And nine hours a week of outside the class work. Those nine hours are going to be primarily working on problem sets. And all the problem sets are going to involve programming in Python, which is the language we're going to be using this term. Now, one of things you're going to see is the first problem sets are pretty easy. Actually, it's probably wrong, John, right, they're very easy. And we're going to ramp up by the time we get to the end of the term, you're going to be dealing with some fairly complex things. So one of the things you're going to see is we're going to make heavy use of libraries, or code written by others. It will allow you to tackle interesting problems with having to write from scratch, but it does mean that this skill here is going to be really valuable, you need to be able to read that code and understand it as well as write your own. Okay. Two quizzes during the term. The dates have already been scheduled, John, I forgot to look them up. I think it's October 2, and November 4, it'll be on the course website. My point is go check the course website, which by the way, is right there. If you have if you know you have a conflict of one of those quiz dates now please see John or I'd right away. We'll arrange something ahead of time. But if you reason I'm saying that as you know, you know that you're getting married that day, for example, we will excuse you from the quiz to get married, will expect you to come right back to do the quiz, by the way, but the boy Tough crowd All right. If you have a conflict, please let us know. Second thing is if you have an MIT documented, special need for taking quizzes, please see John or I well in advance at least two weeks before the quiz again, we'll arrange for this but you need to give us an up warning so that we can deal with that. Okay, the quizzes are open book. This course is not about memory. It's not how well you can memorise facts. In fact, I think both John and I are a little sensitive to memory tests given our age, right, John? This is not about how you memorise things. It's about how you think. So they're open up open book, and it's really going to test your ability to think the grades for the course will be assigned roughly and I use the word roughly because we reserve the right to move these numbers around a little bit. But basically in the following percentages 55% of your grade comes from the problem sets. The other 45 come from the the quizzes and I should have said there's two quizzes and a final exam. I forgot that final exam during final periods. So the quiz percentages are 1015 and 20%. Which makes up the other 45 Okay, Other administrivia I mean, just look through my list here. First problem set, problem set zero has already been posted, this is a really easy Well, we intend it to be really easy problems that is basically to get you to load up Python on your machine and make sure you understand how to interact with it. The first problems that will be posted shortly, it's also pretty boring, somewhat like my lectures, but not John's. And that means, you know, we want you to just to get going on things, don't worry, we're going to make them more interesting as you go along. Nonetheless, I want to stress that none of these problems sets are intended to be lethal. We're not using them to weed you out, we're using them to help you learn. So if you run into a problem set that just you don't get, right seek help, could be psychiatric help, could be a TA, right, I recommend the TA. My point being please come and talk to somebody, the problems are set up so that if you start down the right path, that should be pretty straightforward to work it through. If you start down a plausible but incorrect path, you can sometimes find yourself stuck in the weeds somewhere. And we want to bring you back in. So part of the goal here is this should not be an gruelling, exhausting kind of test. It's really something that should be helping you learn the material. If you need help ask John myself for the TAs. That's what we're here for.</p>

<p>Okay, we're going to run primarily a paperless subject. That's why the website is there, please check it. That's where everything's going to be posted in terms of things you need to know. And I'm particular please go to it today, you will find a forum there that you need to fill out to register for or sign up for rather a recitation. recitations are on Friday. Right now we have them scheduled at 910 1112. One and two, we may drop one of the recitations just depending on course size, right. So we reserve the right unfortunately, to have to move you around. My guess is that nine is not going to be a tremendously popular time, but maybe you'll surprise me. Nonetheless, please go in and sign up, we will let you sign up for whichever recitation makes sense for you. Again, we reserve the right to move people around if we have to, just to balance load, but we want you to find something that fits your schedule rather than ours. Okay, other things, there is no required text. If you feel exposed without a textbook, and you really have to have a textbook, you'll find one recommended actually, I'm going to reuse that word, John, we at least suggested on the course website, I don't think either of us are thrilled with the Texas the best we've probably found for Python, it's okay. If you need it, it's there. But we're going to basically not rely on any specific text. Alright, related to that. Attendance here is obviously not mandatory in high school anymore. I think both of us would love to see your smiling faces, or at least your faces, even if you're not smiling at us every day. point I want to make about this, though, is that we are going to cover a lot of material that is not in the assigned readings. And we do have assigned readings associated with each one of these of these lectures. If you choose not to show up today, or sorry, no future, that's a bad way you didn't choose to show up today, if you choose not to show up in future days, we'll understand. But please also understand that the TAs won't have a lot of patience with you, if you're asking a question about something that was either covered in the readings or covered in the lecture and is pretty straightforward, right? We expect you to behave responsibly, and we will as well. Alright. I think the last thing I want to say is we will not be handing out class notes. Now this sounds like a draconian measure, let me tell you why every study I know of and I suspect everyone, John knows about learning stresses that students learn best when they take notes. Ironically, even if they never look at them. Okay, the process of writing is exercising both halves of your brain. And it's actually helping you learn. And so taking notes is a really valuable thing. Therefore, we're not going to distribute notes. What we will distribute for most lectures is a handout that's mostly code examples that we're going to do, I don't happen to have one today, because we're not going to do a lot of code, we will in future, those notes are going to make no sense. I'm guessing outside of the lecture, right? So it's not just you can swing by at 1104. And grab a copy and go off and get some more sleep. What we recommend is you use those notes to take your own annotations to help you understand what's going on. But we're not going to provide class notes. We want you to take your own notes to help you if you'd like spur your own learning process. Alright, and then finally, I want to stress the John, myself, all of the staff. Our job is to help you learn. That's what we're here for. So we get excited about if you're stuck. If you're struggling. If you're not certain about something, please ask. We're not mind reader's, we can't tell when you're struggling other than sort of seeing the expression on your face. We need your help in identifying that. But all of the TAs, many of whom were sitting down in the front row over here are here to help so come and ask. At the same time, remember that their students too. And if you come and ask a question that you could have easily answered by During the reading, coming to lecture or using Google, they're going to have less patience, but helping you understand things that really are conceptual difficulties, what were their, what they're for here for and what we're here for. So please come and talk to us. Okay, that takes care of the administrivia. preamble, John things we had</p>

<p>Unknown Speaker <br />
two more quick things. By this semester, the class was being videotaped for open courseware. If any of you don't want me to record it, and post it on the web, you're supposed to sit in the back three rows</p>

<p>Eric Grimson <br />
back. Thank you, I forgot.</p>

<p>Unknown Speaker <br />
I think you're all very good looking. And please feel free to be.</p>

<p>Eric Grimson <br />
I'll turn around. So if you want to, you know, move to the back. I won't see who moves. Alright. Great. Thank you, John.</p>

<p>Unknown Speaker <br />
The other thing I want to mention is, recitations are also very important. We will be covering material and recitations that are not in the lectures, not in the reading. And we do expect you to attend recitations.</p>

<p>Eric Grimson <br />
Great. Thanks, John. Any questions about the administrivia? I know it's boring, but we need to do it. So you know what the ground rules are? Good. Okay. Let's talk about computation. So I said, our strategic goal, our tactical goals are to help you think like a computer scientist. Another way of saying it is we want to give you the skill so that you can make the computer do what you want it to do. And we hope that at the end of the class, every time you're confronted with some technical problem, one of your first instinct is going to be how do I write a piece of code? That's going to help me solve that? So we want to help you think like a computer scientist? Right? And that is an interesting statement. What does it mean to think like a computer scientist?</p>

<p>Well, let's see. Primary knowledge you're going to take away from this course, is this notion of computational problem solving this ability to think in computational modes of thought. In online, unlike in a lot of introductory courses, it's a consequence, having the ability to memorise is not going to help you it's really learning those notions of the tools that you want to use. What in the world? Does it mean to say computational motor thoughts? Sounds like a highfalutin phrase you use when you're trying to persuade a VC to fund you? Right? So to answer this, we really have to ask a different question or related questions. So what's computation? Like a strange statement, right? What is computation? And part of the reason for putting it up is that I wanted as much as possible answer that question by separating out the mechanism, just the computer, from computational thinking, right? The artefacts should not be what's driving this, it should be the notion of what does it mean to do computation? Now to answer that, I'm going to back up one more level. And I'm going to impose what sounds like a philosophy question, which is what is knowledge? And you'll see in about two minutes why I'm going to do this, but I want to suggest that I can divide knowledge into at least two categories. Okay, what is knowledge? And the two categories I'm going to divide them into? Are declarative. And imperative. Knowledge. Alright, what in the world is declarative knowledge? Think of it as statements of fact. So assertions of truth. Boy, in this political season, that's a really dangerous phrase to use, right? But it's a statement of fact. I'll stay away from the political comments. Let me give you an example of this, right? Here's a declarative statement. Square root of x is that y, such that y squared equals x, y is positive. You all know that? What I want you to see here is that's a statement of fact, it's a definition, it's an axiom doesn't help you find square roots. If I say x is two, I want to know what's the square root of two? Well, if you're enough of a geek, you'll say 1.41529, or whatever the heck it is. But in general, this doesn't help you find the square root. The closest that doesn't, would let you test. You know, if you're wandering through Harvard Square, and you see a note of work Harvard grad, they're handing out examples of square roots. They'll give you an example. And you can test it to see is the square root of two 1.41529 or whatever? I don't even get laughs at Harvard jokes. John, I'm going to stop in a second here. Right. All right. So what am I trying to say here? It doesn't. It Yeah, exactly. We're staying away from that really quickly, especially with the cameras rolling. All right, what am I trying to say? It tells you how you might test something but it doesn't tell you how to and that's what imperative knowledge is. imperative knowledge is a description of how to deduce something. So let me give you an example of a piece of imperative knowledge. Right? This is actually very old piece of imperative knowledge for computing square. it's attributed to Heron of Alexandria, although I believe that the Babylonians are suspected of knowing beforehand. But here is a piece of imperative knowledge, right? I'm going to start with a guess. I'm going to call it G. And then I'm going to say, if g squared is close to x, stop and return G, it's good enough answer. Otherwise, I'm going to get a new guess, by taking g x over g, adding them. Dividing by two, we will take the average of g and x over g, don't worry about how it came about Heron found this out. But that gives me a new guess. I'm going to repeat. That's a recipe. That's a description of a set of steps. And notice what it has, it has a bunch of nice things that we want to use, right? It's a sequence of specific instructions that I do in order. Along the way, I have some tests, and depending on the value of that test, I may change where I am, in that sequence of instructions. And it has an end test something that tells me when I'm done and what the answer is. This tells you how to find square roots, it's how to knowledge is imperative knowledge. Right? That's what computation basically is about, we want to have ways of capturing this process. Okay, that leads now to an interesting question, which would be how do we build a mechanical process to capture that set of computations. So I'm going to suggest that there's an easy way to do it.</p>

<p>I realised I did the board's in the wrong order here. One of the ways I could do it is you could imagine building a little circuit to do this. If I had a couple of elements that stored values in it, I had some wires to move things around, I had a little thing to do addition, a little thing to do division, and something to do the testing, I could build a little circuit that would actually do this computation. Okay. That strange as it sounds is actually an example of the earliest computers, because the earliest computers were what we call fixed programme. Computers meaning that they had a piece of circuitry designed to do a specific computation. And that's what they would do, they would do that specific computation. You've seen these a lot, right? A good example of this calculator. It's basically an example of a fixed programme. Computer does arithmetic. If you want to play video games on it, good luck, right, you want to do word processing on it, good luck. It's designed to do a specific thing. It's a fixed programme, computer. In fact, a lot of the other really interesting early ones similarly have this flavour. To give an example. I never know how to pronounce this. xs off. 1941, one of the earliest computational things was a thing designed by a guy named Dan ASOF. It basically solve linear equations. handy thing to do if you're doing 1801, right, or 1806, or whatever you want to do those things in. All it could do, though, was solve those equations. One of my favourite examples of an early computer was done by Alan Turing, one of the great computer scientists of all time, called the boom, which was designed to break codes. It's actually in use during World War Two to break German Enigma codes. And what it was designed to do was to solve that specific problem, the point I'm trying to make is fixed programme computers is where we started. But it doesn't really get us to where we'd like to be, we want to capture this idea of problem solving. So let's see how we'd get there. So even within this framework of given a description of computation is a set of steps. And the idea that I could build a circuit to do it, let me suggest for you what would be a wonderful circuit to build. Suppose you could build a circuit with the following property, the input to this circuit, would be any other circuit diagram, give it a circuit diagram for some computation, you give it to this circuit. And that circuit would wonderfully reconfigure itself to act like the circuit diagram, which would mean it could act like a calculator, or it could act like Turing's bomb, or it could act like a square root machine. So what would that circuit look like? You can imagine these tiny little robots wandering around right pulling wires and pulling out two components and stacking together. How would you build a circuit that could take a circuit diagram in it and make the machine act like that circuit? Sounds like a neat challenge. Let me change the game slightly. Suppose instead I want a machine that can take a recipe, a description of a sequence of steps. Take that as its input. And then that machine will now act like what is described in that recipe. reconfigure itself emulated however you want to use the words, it's going to change how it does the computation. That would be cool. And that exists, it's called an interpreter. It is the basic heart of every computer. And what it is doing is saying, change the game. This is now an example of a stored programme computer. What that means in a stored programme computer is that I can provide to the computer a sequence of instructions describing the process I want it to execute. And inside of the machine and things we'll talk about, there is a process that will allow that sequence to be executed, as described in that recipe. So it can behave like any thing that I can describe in one of those recipes. Right? That actually seems like a really nice thing to have. And so let me show you what that would basically look like inside of a stored programme computer, we would have the following.</p>

<p>And have a memory. It's connected to two things control unit. And what's called an Al you an arithmetic logic unit.</p>

<p>This can take in input and spit out output. And inside this stored programme computer, excuse me, you have the following. You have a sequence of instructions. These all get stored in there. Notice the difference. The the recipe, the sequence of instructions is actually getting read in and is treated just like data, it's inside the memory of the machine, which means we have access to it, we can change it, we can use it to build new pieces of code, as well as we can interpret it. One other piece that goes into this computer, I never remember where to put the PC John control, Al you separate, I'll put it separate, we have a thing called a programme counter. And here's the basis of the computation. That programme counter points to some location in memory, typically, to the first instruction in the sequence. And those instructions, by the way, are very simple. They're things like take the value out of two places in memory, and run them through the multiplier in here little piece of circuitry and stick them back into someplace in memory, or take this value out of memory, run it through some other simple operation, stick it back in memory. Having executed this instruction, that counter goes up by one and we move to the next one. We execute that instruction we move to the next one. Oh yeah, it looks a whole lot like that some of those instructions will involve tests, they'll say is something true. And if the test is true, it will change the value of this programme counter to point to some other place in the memory some other point in that sequence of instructions. And you'll keep processing eventually, hopefully stop and a value gets spit out. And you're done. That's the heart of a computer. Now that's a slight misstatement, the process to control it is intriguing and interesting. But the heart of the computer is simply this notion that we build our descriptions or recipes on a sequence of primitive instructions. And then we have a flow of control. And that flow of controls what I just described is moving through a sequence of instructions, occasionally changing where we are, as we move around. Okay. The thing I want you to take away from this, then is to think of this as this is, if you like a recipe, and that's really what a programme is.</p>

<p>sequence of instructions. Now, one of the things I left hanging, as I said, Okay, you build it out a primitive. So one of the questions is, well, what are the right primitives to use? And one of the things that was useful here is that we actually know that the set of primitives that you want to use is very straightforward. Okay, but before I do that, let me drive home this idea of why this is a recipe. Assuming I have a set of primitive instructions that I can describe everything on, I want to know what can I build? Well, I'm gonna do the same analogy to a real recipe. So real recipe, I don't know separate six eggs. Do something. Beat until sorry, beat the whites until they're stiff. Do something until and intestines true. Take the yolks and mix them in with sugar and water, no sugar and flour, I guess that's really what I want sugar and water is not gonna do anything interesting for me here, mix them into something else do a sequence of things. A traditional recipe actually is based on a small set of primitives in a good chef. With or good cook, I should say with that set of primitives can create an unbounded number of great dishes. Same thing holds true programming, right? Given a fixed set</p>

<p>of primitives. A good programmer, can programme anything? And by that I mean anything that can be described in one of these processes you can capture in that set of primitives.</p>

<p>Right? The question is, as I started say, is what are the right primitives? So there's a little bit of a little piece of history here, if you like in 1936, that same guy, Alan Turing, showed that with six simple primitives, anything that could be described in a mechanical process, essentially, algorithmically, could be programmed just using those six primitives. Think about that for a second. That's an incredible statement says with six primitives, I can rule the world with six primitives, I can programme anything. A couple of really interesting consequences of that, by the way. One of them is it says anything you can do in one programming language, you can do in another programming language. You know, there is no programming language that is better. Well, actually, it's not quite true, there are some better doing certain kinds of things. But there's nothing that you can do and see that you can't do in Fortran. It's called Turing compatibility. Anything you can do with one you can do with another, it's based on that fundamental result. Okay. Now, fortunately, we're not going to start with Turing six primitives, this would be really painful programming. Because they're down at the level of take this value, and write it onto this tape. First of all, we don't have tapes anymore, and computers. And even if we did, you don't want to be programming at that level, what we're going to see with programming languages that we're going to use higher level abstracts, a broader set of primitives. But nonetheless, the same fundamental thing holds with those six primitives, you can do it. Okay, so where are we here, we're saying is, in order to do computation, we want to describe recipes we want to describe this sequence of steps are built on some primitives. And we want to describe the flow of control that goes through those sequence of steps as we carry on. So the last thing we need before we can start talking about real programming is we need to describe those recipes. Right? And to describe the recipes, we're going to want a language</p>

<p>we need to know not only what are the primitives, but how do we make things meaningful in that language? Language? There we go. All right. Now, turns out there are I don't know John hundreds 1000s of programming languages, at least hundreds of programming languages around. True, thank you. You know, they all have, you know, their pluses and minuses. I have to admit, in my career here, I think I've taught in at least three languages, I suspect you've taught more five or six, John, both of us have probably programmed in more than those number of languages, at least programme that many since we taught in those languages. One of the things you want to realise is there is no best language, at least I would argue that I think John would agree, we might both agree we have our own nominees for Worst language. There are some of those, there is no best language, right, they all are describing different things. Having said that, some of them are better suited for some things than others. Anybody here heard of MATLAB, maybe programmed in MATLAB scraped for doing things with vectors and matrices and things that are easily captured in that framework. But there's some things that are a real pain to do in MATLAB. So MATLAB is great for that kind of thing. C is a great language for programming things that controlled data networks, for example, I happen to be in John teases me about this regularly. I'm an old time Lisp programming. That's how I was trained. And I happen to like Lisp and Scheme. It's a great language when you're trying to deal with problems where you have arbitrarily structured datasets is particularly good at that. So the point I want to make here is that there's no particularly best language. What we're going to do is simply use a language that helps us understand so in this course, the language we're going to use. Python is a pretty new language, it's growing in popularity. It has a lot of the elements of some other languages because it's more recent, it inherits things from its its progenitors if you like. But one of the things I want to stress is this course is not about Python. Strange statement to you that you do need to know how to use it, but it's not about the details of where do the semi colons go in Python. Alright, it's about using it to think and what you should take away from this course is having learned how to design recipes, how to structure recipes, how to do things in modes, in Python, those same tools easily transferred to any other language, you can pick up another language in a week or a couple of weeks at most, once you know how to do Python. Okay, in order to talk about Python and languages, I want to do one last thing to set the stage for what we're going to do here. And that's to talk about the different dimensions of a language. And the three I want to deal with. The first one is whether this is a high level or low level language. That basically says how close are you to the guts of the machine, a low level language used to call this assembly programming, you're down at the level of your primitives are literally moving pieces of data from one location in memory to another through a very simple operation, a high level language, the designer has created a much richer set of primitive things. In a high level language square root might simply be a primitive that you can use rather than you having to go over and code it. Okay. And there are trade offs between both. second dimension is whether this is a general versus a targeted language. But that I mean, do the set of primitives support a broad range of applications, or is it really aimed at a very specific set of applications, I'd argue that MATLAB is basically a targeted language, it's targeted at matrices, and vectors and things like that. And the third one I want to point out is whether this is an interpreted versus a compiled language.</p>

<p>What that basically says is the following in an interpreted language, you take what's called the source code, the thing you write, it may go through a simple checker, but it basically goes to the interpreter, that thing inside the machine that's going to control the flow of going through each one of the instructions, and give you an output. So the interpreter is simply operating directly on your code at runtime. In a compiled language, you have an intermediate step in which you take the source code runs through what's called a checker or a compiler or both. And it creates what's called object code. And that does two things. One, it helps catch bugs in your code. And secondly, it often converts it into a more efficient sequence of instructions, before you actually go off and run it. Right. And there's trade offs between both I mean, an interpreted language is often easier to debug, because you can still see your raw code there. But it's not always as fast compiled language is usually much faster in terms of its execution, and is one of the things that you may want to trade off. Right, in the case of Python. It's a high level language. I would argue, I think John would agree with me, it's basically a general purpose language, it happens to be better suited for manipulating strings than numbers, for example, but it's really a general purpose language. And it's primarily should separate it is an interpreted language. Okay. As a consequence, is not as good at helping debug, but it does let you try the wrong way saying is not as good at catching some things before you run them. It is easier sometimes in debugging as you go along on the fly. Okay, so what is Python look like? In order to talk about Python. Do it this way. We need to talk about how to write things in Python again, let me back up slightly and set the stage. Our goal is to build recipes. You're all going to be great chefs by the time you're done here. Right? Our goal is to take problems and break them down into these computational steps, the sequence of instructions that allow us to capture that process. To do that we need to describe not only what are the primitives, but how do we capture things legally in that language, and interact with the computer. And so for that we need a language. We're about to start talking about the elements of the language. But to do that, we also need to separate out one last piece of distinction. Just like with a natural language, we're going to separate out syntax versus semantics. So what syntax syntax basically says, what are the legal expressions in this language? Well, my handwriting is atrocious, isn't it? There's a there's an English sequence of words. It's not syntactically correct, right? It's not a sentence. There's no verb in there anywhere. It's just a synchronous announced. Same thing in our languages, we have to describe how do you put together legally formed expressions. And as we add constructs to the language, we're going to talk about that. Second thing we want to talk about very briefly as we go along, is the semantics of the language and here we're going to break out two pieces static semantics in full semantics. static semantics basically says which programmes are meaningful. Which expressions make sense? Here's an English sentence it's syntactically correct. Right noun phrase, verb, noun phrase. I'm not certain it's meaningful unless you are in the habit of giving your furniture, personal names. What's the point? Again, you can have things that are syntactically legal but not semantically meaningful. And static semantic is going to be a way of helping us decide what expressions what pieces of code actually have real meaning to it. Right? The last piece of it is, in addition to having static semantics, we have sort of full semantics. What does the programming or set a different way what's going to happen when I run it?</p>

<p>That's the meaning of the expression, that's what you want. You want to know what's the meaning of this piece of code, when I run it, what's going to happen, that's what I want to build. The reason for pulling this out is what you're going to see is that in most languages, and certainly in Python, we get lots of help here. Right, Python comes built in with something that will check your static sorry, your, your syntax for you. And in fact, as a sidebar, if you turn in a problem set, that is not syntactically correct, there's a simple button that you push, that will check your syntax. If you've turned a programme, that's not syntactically correct, the TAs give you a zero. Because it said you didn't even take the time to make sure this syntax is correct, the system will help you find it. In Python, it'll find it I think, one bug at a time, right, John, it finds one syntax error at a time. So you have to be a little patient do but you can check that the syntax is right, you're going to see that we get some help here. On the static semantics, and I'm going to do an example in a second, meaning that the system some languages are better than others on it, but it will try and help you catch some things that are not semantically correct. Statically. In the case of Python, it does it I think all at runtime, I'm looking to you again, John, I think there's no, there's no pre time checks. It's sorry. There is some, okay. Most of them, I think, though, are primarily caught at runtime. And that's a little bit of a pain, because you don't see it until you go and run the code. There are some actually going to see an example I think in a second where you find it. But you do get some help there. The problem is, things that you catch here are actually the least worrisome bugs, they're easy to spot. You can't run the programme with them, they're so you're not going to get weird answers. Not everything is going to get caught in static semantics checking, some things are going to slide through. And that's actually a bog, it's a problem. Because it says your programme will still give you a value. But it may not be what you intended. And you can't always tell and that may propagate its way down through a whole bunch of other computation before it causes some catastrophic fever. So actually, the problem with static semantics as you'd like it to catch everything, you don't always get it. Sadly, we don't get much help here. Which is where we'd like it, but that's part of your job. Okay, what happens if you actually have something that's both syntactically correct, and appears to have correct static semantics and you run it could run and give you the right answer, could crash could loop forever, it could run and apparently give you the right answer. And you're not always going to be able to tell, well, you'll know when it crashes doesn't help you very much. But you can always tell whether something stuck in an infinite loop or whether it's simply taking a long time to compute, you'd love to have a system that spots that for you, but it's not possible. And so to deal with this last one, you need to develop style. Right meaning, we're going to try and help you with how to develop good programming style, but you need to write in a way in which it is going to be easy for you to spot the places that cause those semantic bugs to occur. All right. Sounds like a really long preamble, it is let's start with Python. But again, my goal here is to let you see what computation is about why we need to do it, I'm going to remind you one last time, our goal is to be able to have a set of primitives that we combine into complex expressions, which we can then abstract to treat as primitives. And we want to use that sequence of instructions in this flow of compute that flow of control computing in order to deduce new information, that imperative knowledge that we talked about right there. So I'm going to start today we have about five or 10 minutes left, I think in order sorry, five minutes left in order to do this with some beginnings of Python. And we're gonna really pick this up obviously next time so simple parts of Python. In order to create any kinds of expressions, we're going to need values, primitive data elements. And in Python we have to start with, we have numbers. And we have strings. Numbers is what you'd expect. There's a number. Here's another number. All right, strings are captured in Python with an open quote, in some sequence of characters, followed by a close quote. associated with every data type in Python is a type, which identifies the kind of thing it is. Some of these are obvious strings are just a type on their own. But for numbers, for example, we can have a variety of types. So this is something that we would call an integer, or an int.</p>

<p>And this is something we would call a floating point or a float. Or if you want to think of it as a real number, and there's some others that we can see, we're gonna build up this this taxonomy if you like, but the reason it's relevant is associated with each one of those types, is a set of operators that expect certain types of input in order to do their job. And given those types of input will give back output. All right, in order to deal with this, let me show you an example. I'm going to hope that comes up great. What I have here is a Python shell. And I'm going to just show you some simple examples of how we start building expressions. And this will lead into what you're going to see next time as well as what you're going to do tomorrow. So starting with the shell, I can type in expressions, actually, let me back up into this and then I can type in a number, I get out the number, I can type in a string and get back the string. Strings By the way, can have spaces in them, they can have other characters as simply a sequence of things. And notice, by the way that the string fifth five, sorry, the string digit five digit two is different than the number 52. The quotes around them to make that distinction, we're gonna see why in a second. What I'm doing, by the way, here's I'm simply typing in expressions to that interpreter, it's using its set of rules to deduce the value and print them back out. Things I might like to do in here is I might like to do combinations of things with these. So we have associated with simple things, set of operations. So for numbers, we have the things you'd expect the arithmetics. And let me show you some examples of that. Next, I'm going to do one other distinction here, what I've typed in things like well, let me start this way. There's an expression. In in Python, the expression is operand, operator operand, when we're doing simple expressions like this, and if I give it to the interpreter, he gives me back exactly what you'd expect, which is that value, okay. The distinction I'm going to make is that's an expression interpreter is going to get a value for it. When we start building up code, we're going to use commands or statements, which are actually things that take any value, and ask the computer to do something with it. So I can similarly do this, which is going to look strange, because it's going to give me the same value back out. But it actually did a slightly different thing. And notice, by the way, when I typed it out, print showed up in a different colour. That's the Python saying that is a command that is a specific command to get the value of the expression and printed back out. When we start writing code, you're going to see that difference. So for now, don't worry about it, I just want to plant that idea. Okay, once we got that, we can certainly though do things like this, notice the quotes around it. And it treats it as a string, it's simply getting the back the value of that string 52 times seven, rather than the value of it. Now once we've got that, we can start doing things and I'm going to use print here, if I could type in order to just get into the hair can't type here we go in order to get into the habit can print out a string. I can print out Ah, here's a first example of something that caught one of my things. This is a static semantic error. So what went on here, I gave it an expression that had an operator in there expected arithmetic types. But I gave it two strings. And so it's complaining at me saying you can't do this. I don't know how to take two strings and multiply them together. Unfortunately, I draw and you may disagree with me on this one. Unfortunately, in Python, you can however do things like this. When you figure that's going to do look legal, the string three times the number three. Well, it happens to give me three threes in a row. I hate this. I'm sorry, John. I hate this because this is overloading that multiplication operator with two different tasks is saying if you give me two numbers, I'll do the right thing. If you give me a number in a string, I'm going to concatenate them together, it's really different operations. But nonetheless, it's what it's going to do.</p>

<p>There you go. You know, there will be a rebuttal phase A little later on, just like with the political debates that he likes it as a feature, I don't like it, you can tell he's not a programmer, and I am. Alright, I want to do a couple more quick examples. Here's another one. Haha, an example of a syntax error. Because five to a doesn't make sense. And you might say, wait a minute, isn't that a string? And the answer is no, I didn't say it's a string by putting quotes around. And notice how the machine responds differently to it. In this case, it says, this is a syntax error. And it's actually highlighting where it came from. So I could go back and fix it. Alright, let's do a couple of other simple examples. Right? I can do multiplication, already seen that I can do addition, three plus five, I can take something to a power double star, just take three to the fifth power. I can do division, right? Well, right. Three divided by five is zero. Maybe in Bush, I can always I'm not going to do any political comments today. I will not say that. Right? What happened? Well, this is one of the places where you have to be careful. It's doing integer division. So 03 divided by by five is zero with a remainder of three. So this is the correct answer. If I wanted to get full real division, I should make one of them a float. And yes, you can look at it and say, well, is that right? Well, up to some level of accuracy. Yeah, that's point six. This is what I like to get out. Right? I can do other things. In particular, I have similar operations on strings. Okay, I can certainly print out strings, but I can actually add strings together. And if you just as you saw, I can multiply strings, you can kind of guess what this is going to do. It is going to merge them together into one thing. I want to know I'm running you slightly over I want to do one last example is I also want to be able to do have variables to store things. To do that, this just says if I have a value, I want to keep it around to do that I can do things like this</p>

<p>what does that statement do? It says create a name for a variable I just did there. In fact, let me type it in my string with an equal sign, which is saying a sign or bind to that name, the value of the following expression. As a consequence, I can now refer to that just by its name. If I get the value of my string, there it is. Or if I say take my string and add to it the string. My last name, I print it back out. This is the first start of this, what have we done. We've got values, numbers and strings. We have an operations associated with them, I just threw a couple up here, you're going to get a chance to explore them. And you'll see not only are there's a standard Numerix. For strings, there are things like length or plus or other things you can do with them. And once I have values, I want to get a hold of them so I can give them names. And that's what I just did when I bound that I said use the name my string to be bound to or have the value of Eric so I can refer to it anywhere else that I want to use it. And I apologise for taking you over we'll come back to this next time. Please go to the website. Sign up for recitation for tomorrow.</p>